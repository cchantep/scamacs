package com.rojoma.util.concurrent

import scala.collection.mutable

/**
 * Implements a tokenized queue.  Entries are associated with tokens,
 * which can be in any of three conceptual states: "untaken" (there is
 * an available entry in the queue), "taken" (the item has been
 * <code>dequeue</code>d), or "released"; when a <code>dequeue</code>
 * operation is performed, the oldest entry with an "untaken" token is
 * returned along with that token.  No further entries associated with
 * it will be returned until the token is <code>release</code>d.
 * Methods are provided that take a processing function and ensure the
 * <code>release</code> of the token when the function exits.
 */
class BlockingTokenQueue[T,E] {
  private[this] case class Entry(priority: Long, token: T, entry: E) extends Ordered[Entry] {
    def compare(that: Entry): Int = priority.compare(that.priority)
  }
  
  private[this] class UnreleasedTokenRecord {
    var taken = false
    val remainingEntries = new mutable.Queue[Entry]
  }

  // Invariants:
  //  * threads wait in dequeue only if waitingJobs is empty
  //  * UnreleasedTokenRecord#taken is false if and only if the token is in state "untaken"
  //  * There is at most one job associated with a given token in the queue
  //  * There is an entry in tokenRecords if and only if the token is not in state "released"
    
  // If Entry were replaced with a simple (token, entry) pair, and this
  // were replaced by a plain Queue, release() would lose its queue-
  // jumping behaviour, but there might be less total overhead, and the
  // intra-token ordering would remain unchanged.
  private[this] val waitingEntries = new mutable.PriorityQueue[Entry]
  private[this] val tokenRecords = new mutable.HashMap[T, UnreleasedTokenRecord]
  private[this] var lastPriority = Long.MinValue // will wrap around to MaxValue on first enqueue

  /**
   * Tests for the existence of items which have not yet been
   * <code>dequeue</code>d.  This includes items which are not
   * presently available because their tokens are in state "taken".
   *
   * @return "<code>true</code>" if the number of <code>enqueue</code>s done
   * to this object is equal to the number of completed <code>dequeue</code>s.
   */
  def isEmpty: Boolean = synchronized {
    waitingEntries.isEmpty && tokenRecords.valuesIterator.forall(_.remainingEntries.isEmpty)
  }
  
  /**
   * Tests for the existence of tokens in the "untaken" state.
   * This is primarily for testing purposes; use <code>dequeue</code> with a timeout
   * of zero for an atomic check-and-get.
   * 
   * @return "<code>true</code>" if <code>dequeue</code> would not block
   */
  def hasAvailable: Boolean = synchronized {
    !waitingEntries.isEmpty
  }
  
  /**
   * Enqueues an object.  This is an O(1) operation.  Returns true
   * if there were no untaken entries with this token in the queue before.
   */
  def enqueue(token: T, entry: E): Boolean = synchronized {
    lastPriority -= 1
    val ent = Entry(lastPriority, token, entry)

    tokenRecords.get(token) match {
      case None =>
        // state was "released"; move to state "untaken"
        tokenRecords(token) = new UnreleasedTokenRecord
        waitingEntries += ent // constant-time operation because of the implementation of PriorityQueue.+=
        notify()
        true
      case Some(tokenRecord) =>
        // state was "untaken" or "taken"; save the entry for the next call to release
        tokenRecord.remainingEntries += ent
        tokenRecord.taken && tokenRecord.remainingEntries.length == 1
    }
  }

  private[this] def finalizeDequeue() = {
    // Preconditions: !waitingEntries.isEmpty, monitor lock held, token in state "untaken"
    // Postconditions: monitor lock held, token in state "taken"
    val Entry(_, token, entry) = waitingEntries.dequeue()
    tokenRecords(token).taken = true
    if(!waitingEntries.isEmpty) notify() // There's more work to do, so wake someone up if they're there
    (token, entry)
  }
  
  /**
   * Return the oldest available <code>(token, element)</code> pair,
   * blocking until one becomes available.  When one is available, this is
   * an O(log&nbsp;u) operation, where u is the number of tokens in state "untaken".
   * 
   * @return The oldest element whose associated token is in state
   * "untaken", together with that token
   * 
   * @throws <code>InterruptedException</code> if the thread is interrupted while waiting
   */
  def dequeue(): (T,E) = synchronized {
    while(waitingEntries.isEmpty) wait() // Wait for an untaken token
    finalizeDequeue()
  }
  
  /**
   * Return the oldest available <code>(token, element)</code> pair,
   * blocking up to <code>timeout</code> milliseconds until one
   * becomes available.  When one is available, this is an O(log&nbsp;u) operation,
   * where u is the number of tokens in state "untaken".
   * 
   * @return <code>Some((token,element))</code>, or <code>None</code>
   * if the <code>timeout</code> expired
   * 
   * @throws <code>InterruptedException</code> if the thread is
   * interrupted while waiting
   */
  def dequeue(timeout: Long): Option[(T,E)] = synchronized {
    if(waitingEntries.isEmpty) { // No "untaken" tokens, need to wait
      val start = System.currentTimeMillis
      val deadline = start + timeout.max(0L)

      // @tailrec
      def sleepThenDequeue(now: Long): Option[(T,E)] = {
        if(deadline <= now) None
        else {
          wait(deadline - now)
          if(waitingEntries.isEmpty) {
            sleepThenDequeue(System.currentTimeMillis)
          } else {
            Some(finalizeDequeue())
          }
        }
      }
      
      if(deadline > 0) {
        sleepThenDequeue(start)
      } else {
        // The timeout is so large it wraps around when added to start.
        // Since the user won't care if we actually wake up in the
        // year 300 million (give or take a few mil), just sleep
        // forever.  This was probably a call like dequeue(Long.MaxValue).
        Some(dequeue())
      }
    } else {
      Some(finalizeDequeue())
    }
  }
  
  /**
   * Release a token for further processing, signalling that any work
   * associated with the last-<code>dequeue</code>d element is done.  This
   * is an O(1) operation if there are no more items in the queue which
   * share this token, or O(log&nbsp;u) where u is the number of tokens in state
   * "untaken" if there are.
   * 
   * @throws <code>TokenReleaseException</code> if the token is not in
   * state "taken".
   */
  def release(token: T): Unit = synchronized {
    val tokenRecord = tokenRecords.getOrElse(token, throw AlreadyReleasedException(token))
    if(!tokenRecord.taken) throw AlreadyUntakenException(token)
    
    if(tokenRecord.remainingEntries.isEmpty) {
      // No more work associated with this token; move to state "released"
      tokenRecords -= token
    } else {
      // There's more work, so move to state "untaken"
      tokenRecord.taken = false
      waitingEntries += tokenRecord.remainingEntries.dequeue()
      notify() // If someone's waiting, give 'em a chance to take it
    }
  }
  
  /**
   * Perform some action on the oldest available element.  Ensures
   * that its token is <code>release</code>d afterward.
   * 
   * @return The value returned from the provided function
   * 
   * @throws <code>InterruptedException</code> if the thread is
   * interrupted while waiting
   */
  def withEntry[R](f: E => R): R = {
    val (token, entry) = dequeue()
    try {
      f(entry)
    } finally {
      release(token)
    }
  }
  
  /**
   * Perform some action on the oldest available element, if one
   * becomes available within <code>timeout</code> milliseconds.
   * Ensures that its token is <code>release</code>d afterward.
   * 
   * @return The value returned from the provided function.
   * 
   * @throws <code>InterruptedException</code> if the thread is
   * interrupted while waiting
   */
  def withEntry[R](timeout: Long)(f: Option[E] => R): R = {
    dequeue(timeout) match {
      case None =>
        f(None)
      case Some((token, entry)) =>
        try {
          f(Some(entry))
        } finally {
          release(token)
        }
    }
  }
}

sealed abstract class TokenReleaseException[T](msg: String) extends Exception(msg) {
  def token: T
}

object TokenReleaseException {
  def unapply[T](x: TokenReleaseException[T]): Option[T] = Some(x.token)
}

final case class AlreadyReleasedException[T](token: T) extends TokenReleaseException[T]("Released an unknown token: " + token)
final case class AlreadyUntakenException[T](token: T) extends TokenReleaseException[T]("Released a token with an available entry: " + token)